#include <stdio.h>
#include <stdlib.h>
#include "lex.h"
#include "ast.h"

static ast* parse_program(lexer* lex);
static ast* parse_line(lexer* lex);
static ast* parse_statement(lexer* lex);

static ast* parse_let(lexer* lex);
static ast* parse_print(lexer* lex);
static ast* parse_input(lexer* lex);
static ast* parse_goto(lexer* lex);
static ast* parse_if(lexer* lex);
static ast* parse_gosub(lexer* lex);
static ast* parse_return(lexer* lex);
static ast* parse_end(lexer* lex);
static ast* parse_rem(lexer* lex);

static ast* parse_expr(lexer* lex);
static ast* parse_term(lexer* lex);
static ast* parse_factor(lexer* lex);

static int accept(lexer* lex, token_type t);
static void expect(lexer* lex, token_type t, const char* msg);

// --------------------------------------------
// Entry point
// --------------------------------------------
ast* parse(lexer* lex)
{
    return parse_program(lex);
}

// --------------------------------------------
// program ::= { line }
// --------------------------------------------
ast* parse_program(lexer* lex)
{
    ast* prog = init_node(AST_PROGRAM, NULL);

    while (lex->current_token.type != TOK_EOF) {
        ast* line = parse_line(lex);
        ast_add_child(prog, line);
    }

    return prog;
}

// --------------------------------------------
// line ::= number statement
// --------------------------------------------
ast* parse_line(lexer* lex)
{
    if (lex->current_token.type != TOK_NUMBER)
        printf("Syntax error: expected line number\n");

    int line_no = atoi(lex->current_token.value);
    expect(lex, TOK_NUMBER, "line number");

    ast* line_node = init_node(AST_LINE, NULL);
    line_node->int_value = line_no;

    ast* stmt = parse_statement(lex);
    ast_add_child(line_node, stmt);

    return line_node;
}

// --------------------------------------------
// statement ::= (choose based on token)
// --------------------------------------------
ast* parse_statement(lexer* lex)
{
    switch (lex->current_token.type) {
        case TOK_LET:   return parse_let(lex);
        case TOK_PRINT: return parse_print(lex);
        case TOK_INPUT: return parse_input(lex);
        case TOK_GOTO:  return parse_goto(lex);
        case TOK_IF:    return parse_if(lex);
        case TOK_GOSUB: return parse_gosub(lex);
        case TOK_RETURN:return parse_return(lex);
        case TOK_END:   return parse_end(lex);
        case TOK_REM:   return parse_rem(lex);
        default:
            printf("Unknown statement\n");
            exit(1);
    }
}

// --------------------------------------------
// let-stmt ::= (LET)? var '=' expr
// --------------------------------------------
ast* parse_let(lexer* lex)
{
    expect(lex, TOK_LET, "LET");

    if (lex->current_token.type != TOK_VAR)
        printf("LET: expected variable\n");

    char varname = lex->current_token.value[0];
    expect(lex, TOK_VAR, "variable");

    expect(lex, TOK_EQ, "=");

    ast* expr = parse_expr(lex);

    ast* node = init_node(AST_LET, NULL);
    node->var_name = varname;
    ast_add_child(node, expr);
    return node;
}

// --------------------------------------------
// print-stmt ::= PRINT print-list
// --------------------------------------------
ast* parse_print(lexer* lex)
{
    expect(lex, TOK_PRINT, "PRINT");

    ast* node = init_node(AST_PRINT, NULL);

    // print-item { (;|,) print-item }
    for (;;) {

        if (lex->current_token.type == TOK_STRING) {
            ast* s = init_node(AST_STRING, lex->current_token.value);
            ast_add_child(node, s);
            accept(lex, TOK_STRING);
        } else {
            ast* e = parse_expr(lex);
            ast_add_child(node, e);
        }

        if (accept(lex, TOK_COMMA) || accept(lex, TOK_SEMI))
            continue;

        break;
    }

    return node;
}

// --------------------------------------------
// INPUT var
// --------------------------------------------
ast* parse_input(lexer* lex)
{
    expect(lex, TOK_INPUT, "INPUT");

    if (lex->current_token.type != TOK_VAR)
        printf("INPUT: expected variable\n");

    char varname = lex->current_token.value[0];
    expect(lex, TOK_VAR, "variable");

    ast* node = init_node(AST_INPUT, NULL);
    node->var_name = varname;
    return node;
}

// --------------------------------------------
// GOTO number
// --------------------------------------------
ast* parse_goto(lexer* lex)
{
    expect(lex, TOK_GOTO, "GOTO");

    int target = atoi(lex->current_token.value);
    expect(lex, TOK_NUMBER, "target line");

    ast* node = init_node(AST_GOTO, NULL);
    node->int_value = target;
    return node;
}

// --------------------------------------------
// IF expr relop expr THEN number
// --------------------------------------------
ast* parse_if(lexer* lex)
{
    expect(lex, TOK_IF, "IF");

    ast* lhs = parse_expr(lex);

    token_type relop = lex->current_token.type;
    expect(lex, relop, "relop");

    ast* rhs = parse_expr(lex);

    expect(lex, TOK_THEN, "THEN");

    int target = atoi(lex->current_token.value);
    expect(lex, TOK_NUMBER, "line number");

    ast* node = init_node(AST_IF, NULL);
    node->relop = relop;
    node->int_value = target;

    ast_add_child(node, lhs);
    ast_add_child(node, rhs);

    return node;
}

// --------------------------------------------
ast* parse_gosub(lexer* lex)
{
    expect(lex, TOK_GOSUB, "GOSUB");

    int target = atoi(lex->current_token.value);
    expect(lex, TOK_NUMBER, "number");

    ast* node = init_node(AST_GOSUB, NULL);
    node->int_value = target;
    return node;
}

ast* parse_return(lexer* lex)
{
    expect(lex, TOK_RETURN, "RETURN");
    return init_node(AST_RETURN, NULL);
}

ast* parse_end(lexer* lex)
{
    expect(lex, TOK_END, "END");
    return init_node(AST_END, NULL);
}

// REM anything until EOL
ast* parse_rem(lexer* lex)
{
    expect(lex, TOK_REM, "REM");

    // take full comment string stored by lexer
    ast* node = init_node(AST_REM, lex->current_token.value);
    accept(lex, TOK_REST_OF_LINE);

    return node;
}

// --------------------------------------------
// Expressions
// --------------------------------------------
ast* parse_expr(lexer* lex)
{
    ast* node = parse_term(lex);

    while (lex->current_token.type == TOK_PLUS ||
           lex->current_token.type == TOK_MINUS) 
    {
        token_type op = lex->current_token.type;
        accept(lex, op);

        ast* rhs = parse_term(lex);

        ast* parent = init_node(AST_BINOP, NULL);
        parent->op = op;
        ast_add_child(parent, node);
        ast_add_child(parent, rhs);

        node = parent;
    }

    return node;
}

ast* parse_term(lexer* lex)
{
    ast* node = parse_factor(lex);

    while (lex->current_token.type == TOK_MUL ||
           lex->current_token.type == TOK_DIV) 
    {
        token_type op = lex->current_token.type;
        accept(lex, op);

        ast* rhs = parse_factor(lex);

        ast* parent = init_node(AST_BINOP, NULL);
        parent->op = op;
        ast_add_child(parent, node);
        ast_add_child(parent, rhs);

        node = parent;
    }

    return node;
}

ast* parse_factor(lexer* lex)
{
    if (accept(lex, TOK_LPAREN)) {
        ast* node = parse_expr(lex);
        expect(lex, TOK_RPAREN, ")");
        return node;
    }

    if (lex->current_token.type == TOK_NUMBER) {
        int v = atoi(lex->current_token.value);
        expect(lex, TOK_NUMBER, "number");
        ast* n = init_node(AST_NUMBER, NULL);
        n->int_value = v;
        return n;
    }

    if (lex->current_token.type == TOK_VAR) {
        char v = lex->current_token.value[0];
        expect(lex, TOK_VAR, "variable");
        ast* n = init_node(AST_VAR, NULL);
        n->var_name = v;
        return n;
    }

    printf("Syntax error: bad factor\n");
    exit(1);
}

// --------------------------------------------
// Helpers
// --------------------------------------------
int accept(lexer* lex, token_type t)
{
    if (lex->current_token.type == t) {
        lexer_next_token(lex);
        return 1;
    }
    return 0;
}

void expect(lexer* lex, token_type t, const char* msg)
{
    if (!accept(lex, t)) {
        printf("Expected %s\n", msg);
        exit(1);
    }
}
